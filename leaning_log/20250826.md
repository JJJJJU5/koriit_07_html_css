# color / image 웹페이지 꾸미기

## 배경 꾸미기

### 배경에 그라데이션 넣기

- 그라데이션 : 두 가지 이상의 색을 이용하여 두 색을 점점 변화시켜가며 채색하는 방식.(웹 사이트에서 흔히 사용되지는 않음)

https://showcases.yalco.kr/html-css/02-08/02.html

1. background 속성의 속성 값으로 linear-gradient(색1, 색2)
2. liner-gradient(각도(deg), 색1, 색2)

- 참고 : deg -> degree

3. linear-gradient(각도, 색1, 퍼센트값 , 색2)

- 이전까지는 색상이 반반씩 나왔는데, 첫 번째 색의 구간을 지정하는 방식으로 퍼센트값을 넣는다

4. linear-gradient(색1, 색2, 색3)

- 참고: linear-gradient(색1 퍼센트값 1, 색2 퍼센트값 2, 색3 퍼센트값 3)

11_gradient.html / 11_gradient.css 참조

## 포지셔닝

HTML로 작성한 문서(웹 페이지)는 하나의 기기로만 여는 것이 아니기 때문에 상대적이다. 따라서 요소의 위치를 잡는 데 포지셔닝이 매우 중요한 역할을 한다. 그것의 기초가 `<span>`과 `<div>`의 성격 차이였다. 어제 dispaly: inline / block / inline-bloca을 배웠다.

https://showcases.yalco.kr/html-css/02-09/01.html

12_position.html / 12_position.css

- 특정 HTML 요소들이 해당 페이지에서 어떻게 배치될지를 설정하는 데 사용.
- `position 속성은 부모 요소의 것이지 자식에게 대물림되지 않음` -> yellow의 position 속성이 red로 이어지지 않음을 뜻함.

1. static

- position 속성의 default 값으로 top /left 등의 위치 조정을 하더라도 위치 이동 x -> HTML 구조를 따르는 것.

2. relative

- 상대적인, 이라는 의미로 위치 이동이 가능.
- 자신의 HTML 구조 상에서의 위치에서 이동하게 됨.
- 해당 요소의 위치가 이동하지만 요소가 차지하는 공백은 그대로 유지하게 됨.
  -> 그 결과 가장 상위 div의 범위를 벗어난다 하더라도 6번 div가 5번 div 자리로 이동하지 않음 즉, 공백을 유지함.

3. absolute

- 절대적인, 이라는 의미로 첫 부모 요소`(static이 아닌 상태로 만나는 상위 HTML 구조)`의 속성값을 이용하여 위치이동이 가능(relative랑 다른 좌표가 필요함.)
- 이상의 경우는 또 relative와 달리 공백 요소를 고정하지 않고 첫 부모의 좌표를 따라서 움직이기 때문에 공백이 생기게 될 경우 다음 div가 공백을 채우는 위치로 이동하는 것을 볼 수 있다. 위치 이동이 일어나는 이유는 display: inline-block 때문이다.
- 그래서 .yellow가 static인 상태로 .red를 position: absolute; top: 100px; left: 100px;로 잡을 경우 .yellow가 첫 부모가 아니기 때문에 ` 그 상위인 outer가 첫 부모 요소가 되고`, 때문에 회색 borderline을 가진 div 기준으로 아래에 100px, 오른쪽으로 100px을 이동한 위치가 된다.
- yellow의 position을 rerlative로 잡게 되면 첫 부모 요소가 되기 때문에 노란색 div 기준으로 아래쪽으로 100px, 오른쪽으로 100px 이동한 위치로
  .red가 이동하게 된다.'

4. fixed

- 고정된, 이라는 의미로, 부모 요소가 아니라 뷰포트viewport를 기준으로 위치를 지정함. outer보다 더 위에 있는 브라우저 흰색 부분을 기준으로 하기 때문에 똑같이 .red를 top: 100px; left: 100px;을 적용하더라도 위치가 약간 위/왼쪽으로 이동하는 것
- 뷰포트에 `고정된` 위치를 사용하기 때문에 브라우저의 스크롤링에 영향을 받지 않는다(스크롤을 움직이면 같이 움직이는 형태)
- 해당 속성을 사용하게 될 경우, 특정 팝업창을 띄었을 때 스크롤과 상관없이 한 곳에 고정시킬 때 자주 사용하는 속성이다.

5. sticky

- 특정 요소가 스크롤로 이동할 수 있는 공간을 top / bottom / left / right / z-index 속성값을 이용하여 지정 가능함.
- 예를 들어 홈페이지에서 nav에 해당하는 부분이 일정 수준까지는 아래로 스크롤링했을 때 따라 내려오는데, 그 부분을 지나게 되면 따라오지 않는 등의 효과를 줄 떄 사용함.

- 부모 요소의 여백에 영향을 받음.자식 요소의 위치를 고정하더라도 스크롤하면서 부모 요소의 위치를 벗어난다면, 자식 요소는 그 이상 움직이지 못함. 이상을 이유로 sticky는 부모 요소의 안쪽이 아니라 동등 / 바깥쪽 요소에 지정하는 것이 좋습니다.

### z-index 속성

https://showcases.yalco.kr/html-css/02-09/02.html

- static이 아닌 모든 경우에 각 요소들간에 높이 차이를 주게 됨으로써 요소들간의 배치를 효율적으로 하기 위한 값
- 겹쳐지는 순서를 인위적으로 바꾸고자 할 때 사용함.
- z-index의 default 값은 auto로 설정되어있는데, 이는 0을 의미함.
- 0보다 큰 값을 지니고 있다면 상위로 올라가게 됨
- 이상을 이유로 광고창 등의 경우 무조건 상위에 있어야하기 때문에 css 파일 확인하면 z-index:999; 같은 것도 구경할 수 있다.

13_zindex.html /13_zindex.css

## flex 레이아웃

- 모든 웹사이트는 큰 레이아웃 형태의 구조로 되어있고, 이 레이아웃을 만드는 방법은 다양하다. 예전에는 HTML 테이블 구조와 블록/인라인의 조합으로 사이트 구조를 만들어야 했는데, 오늘날 flex가 나오면서 각종 CSS 기능을 통해 레이아웃을 설정하게 되었다.

### 부모에 적용하는 flex

참조
https://showcases.yalco.kr/html-css/02-11/01.html

- 참고 : 부모에 적용하는 속성이라는 것은 부모 라인 관련 css에 작성한다는 뜻으로 사용한다.

참조 사이트를 기준으로 바깥쪽 div에 display : flex;를 적용했을 때와 display: inline-flex를 적용했을 때의 p태그 위치가 바뀌는 점을 확인할 수 있다.

이상의 차이에서 확인할 수 있는 점 :

1. display: flex;를 div에 적용했을 경우 block 성질은 그대로 유지된 상태로 flex가 적용됨

- 그래서 p 태그가 개행된 상태로 출력

2. display: inline-flex;를 div에 적용했을 경우 block 성질이 inline으로 바뀌게 되면서 회색 div 영역 이후의 부분에 p태그의 텍스트가 출력됨.

1. flex-direction 속성

- 내부의 자식 요소들을 어느 축을 기준으로 정렬할지 결정.
- default 값은 row(왼쪽부터 차례대로 정렬함) -> 자식 요소들을 row로 정렬하기 때문에 참조 사이트 기준 1, 2, 3 div가 새로로 길게 출력됨.

2. justify-content

- 메인 축에서 내부 요소를 정렬하는 방식을 결정.
- default 값은 flex-start: 왼쪽부터 내부 요소 정렬
- center: 텍스트 중앙 정렬한 것처럼 내부 요소들을 중앙에 배치함.
- flex-end: 메인 축의 끝 부분인 오른족으로 내부 요소가 정렬됨 순서는. flex-direction을 따른다.
- space-between: 맨 왼쪽과 오른쪽에 하나씩 배치하고 그 사이에 나머지 요소들을 균등하게 배치
- space-around: 각 내부 요소의 양쪽에 일정한 크기의 빈 공간을 배치. -> 1번 div 좌우에 margin처럼 보이는 것이 있고, 2번 div의 좌우에 margin이 있는 것처럼 보여서 중간 부분만 비어보인다.
- space-evenly : 모든 빈 공간의 크기를 고르게 지정

3. align-items : flex의 메인 축에서의 반대편 축(즉 flex-direction: row;라면 y축 방향으로, flex-direction: column;이라면 x축 방향으로) 내부 요소를 정렬할 방식을 결정함.

- () 내부의 내용을 토대로 flex-direction: row; 라면 반대 방향인 세로 방향으로 stretch가 일어나서 세로로 긴 div이 3개 생겼다고 볼 수 있다.
- stretch : align-items 의 default값으로 이상의 설명처럼 길게 늘린다.
- flex-start : min-width / min-height의 크기 그대로 정렬하는 위치를 왼쪽 상단으로 시작함.
- center : 중앙 정렬
- flex-end : 수직 축의 끝 부분인 아래로 정렬

- 참고 : display:flex / flex-direction / align-items는 대부분 세트로 같이 돌아다니기 때문에 `https://showcases.yalco.kr/html-css/02-11/01.html`사이트에서 이리저리 움직여보고 css 값을 넣어보는 것도 좋은 방법이다.

4. flex-wrap

- 내부 요소들이 자식 요소의 영역을 넘어가는 부분을 전제로 배치 방식을 자동으로 바꿔주는 속성값
- default 값 : no-wrap
- wrap으로 설정하게 되면 내부 요소가 부모 요소를 넘어가지 않도록 줄바꿈이 일어남. 주로 컨텐츠가 한 줄이 아니라 여러 줄일 때 사용
- 페이지 상에서의 효과를 보면 min-width / min-height를 가지고 있는 상태에서 최대한 stretch가 적용되어 부모 div의 영역을 차지하는 것을 확인할 수 있습니다. 만약에 그게 보기 싫으면 stretch를 flex-start / center / flex-end로 바꾸면 된다

5. align-content

- align-items와 혼동이 일어나기 쉽다. align-items의 경우에는 flex-start / center / flex-end를 적용했을 경우 가운데 여백이 같은 크기의 공백으로 나뉘어진 상태에서 내부 요소가 위 / 중간 / 아래에서 정렬이 일어나게된다. 그래서 첫째줄과 둘째줄 사이에 공백이 있다.

- 반면 align-content를 사용했을 경우 1번 ~ 12번 div이 하나의 묶으로 공백없이 정렬된 상태에서 위 / 중간 / 아래에 정렬이 일어난다.

6. gap - 내부 요소들 사이에 들어가는 공백의 크기를 지정(그러니까 자식 div의 margin 적용하는거랑 혼동하기가 쉽다)

### 자식에 적용하는 flex

1. flex-basis / flex-shrink

- 자식에 flex 관련 속성을 사용하기 위해서는 부모의 css에 display : flex;가 적용되어 있어야 한다. 그리고 아까 위에서 설명한 것처럼 세트인 flex-direction을 적용해야 한다. 이제 설명하는 부분은 flex-direction: row;를 기준으로 하는 것

- `부모 요소에서 flex-direction: row;`이므로 자식 요소에서의 flex-basis는 row방향으로 크기를 지정한다.
- deefault 값은 auto;
- 절대값 / 상대값을 적용할 수 있다.

- 만약에 자식 요소의 flex-basis를 절대값으로 잡는 바람에 부모 요소의 크기를 거기에 맞춰서 강제로 증가시키게 된다면 반응형 페이지라고 할 수 없다.
- 해당 경우에 사용하는 것이 flex-shrink이다.
- default 값 : 1
  - 전체 공간이 부족할 경우 해당 내부 요소의 크기가 컨텐츠(여기서는 주황색 div)의 width 또는 flex-basis의 최대 크기가 부모 요소를 넘어가지 못하도록 강제하는 값

2. flex-grow

- defalut 값 : 0 = 기존의 크기를 그대로 유지함
- 숫자의 크기에 따라 나머지 형제 요소들의 공백 크기의 곱만큼 자기가 커진다.(커지는 방향은 부모의 flex-direction 설정값에 따름.)

## 요소를 감추는 방법

1. 원래 보이던 요소를 투명하게 만드는 방법
2. 요소가 보이지 않으면서 가지고 있는 기능 자체도 날리는 방법

### CSS에서 요소를 숨기는 세 가지 방법

참조 `https://showcases.yalco.kr/html-css/02-10/02.html`

1. opacity 속성 활용

- 불투명도를 뜻하며 범위는 0 ~ 1 사이의 값. 0으로 하면 불투명도 0이기 때문에 투명해진다.
- 해당 요소를 투명하게 만드는 것이기 때문에 기능은 존재한다.
- 예전 악성 광고 사이트 같은곳에서 사용하던 방법인데 광고팝업을 opacity:0;로 설정해서 클릭하면 광고 페이지로 넘어가게 하는 방식

2. visibility 속성 활용

- visibility의 속성 값 : visible / hidden 두 가지로, hidden을 경우에 숨겨짐
- 기능도 사라진다.
- 하지만 공백은 남아있다. 보이는지 안보이는지만 지정했기 때문에 안보이는 상태에서 기능해제까지 도입되었다고 볼 수 있다.

3. display 속성 활용

- 많은 속성값이 있었다
- flex
- block
- inline
- inline-block
- 참조 사이트에서는 div들이 일렬로 나열되어야 하기 때문에 inline-block만 나와있었다.
- 그리고 none을 쓰게 되면
  - 눈에 안보이고 / 기능도 삭제되고 / 아예 없는게 되기 때문에 뒤에 있던 div가 앞으로 당겨져서 공백이 사라지는 것을 확인 할 수 있다.

# CSS 고급 기능(최근에 필수)

## 반복 및 공통되는 스타일

- CSS를 사용하다보면 여러 페이지에서 같은 코드를 반복해서 사용하는 일이 생기는데. CSS에서 공통적으로 사용되는 코드를 `모듈화`하여 다른 CSS 파일로 임포트하는 방법. 그리고 자주 사용하는 속성값을 변수명으로 지정하는 방법

### 다른 CSS 파일을 임포트하기

형식 :
`@import url(불러올 CSS 파일 경로)`
ch07_applied_style
01_cssimport.html / 01_cssimport.css / 00_shared.css

```html
<!-- 00_shared.css -->
 .sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
<!-- 01_cssimport.css -->
 </* 외부 css 파일 import */'
@import url(./00_shared.css);
body {
  margin: 0;
  padding: 24px;
}
```

이상의 결과 화면을 확인했을 때 HTML 문서상에서 .sr-only 클래스명을 사용한 `<p>` 태그 내용이 보이지 않도록 숨겨지는 것을 확인할 수 있다. 아는 특정 문단의 내용을 감추는 설정이 담긴 shared.css 파일을 @import를 통해서 외부에서 가지고 와서 01_cssimport.css 에서 사용했기 때문이다.

이상처럼 HTML 문서를 사용할 때에 CSS를 적용하는 방식으로

1. inline 방식
2. internal style sheet(내부 스타일 시트) 방식
3. linking style sheet(링킹 스타일 시트) 방식
4. @import (임포트 방식) 외부에서 CSS 가지고 오는 방식
   을 들 수 있따 상황에 따라서 선택이 가능함

### CSS 변수 사용하기

- 변수(variable) : 특정한 데이터에 이름을 붙이는 것을 의미한다.

예를 들어 .html을 생성할 때 마다 body 태그 내에 bgcolor-"5f5f5f"를 사용해 왔다. 하지만 크림슨 바이올렛 같은 색깔의 HEX 값을 외우기 어려운 경우가 있다 . 값이 하나만 틀려도 다른 색이 나오니 기억하기 쉬운 이름 , 즉 변수를 붙이면 사용하기가 편리해진다.

- CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고, 그 앞에 `--`입려해서 변수임을 표시한다. 예를 들어서 디자이너와 프론트엔드 개발자 간에 소통하게 될 때 특정 색깔을 브랜드 메인 컬러로 설정했다면,
  `--color-main`, 그 다음 서브 컬러라면``--color-sub1`과 같은 방식으로 지정하는 것 가장 작은 폰트 사이즈를 지정한다면 `--font-small`와 같은 방식

02_cssvariable.html / 02_cssvariable.css / 00_common.css

현재 상황을 고려했을 때, 00_common.css 에서 공통적으로 사용되는 변수 목록들을 설정했음. 디자이너들이 정해주는 폰트 크기 색상, 자간, 줄, 간격 등을 모조리 변수화한 다음에 특정 프로젝트 전용으로만 쓰는 편

그리고 02*cssvariable.css에서 `@import url(./00_common.css)`를 통해서 *해당 파일의 변수 목록을 참조할 수 있도록 import 문을 작성\_ 하였다.

- var() -> 특정 CSS 변수의 데이터값을 불러오는 함수
  그런데 i태그의 class="not-good" / b태그의 class=wrong을 적용 했을 때에는 아무런 차이가 없다. p태그에 공통적으로 적용한 부분만 나왔다.

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cssvariable 학습하기</title>
    <link rel="stylesheet" href="02_cssvariable.css" />
  </head>
  <body>
    <h1>제목 부분</h1>
    <p>
      <u class="not-good"> u태그의 not good을 적용한 부분 </u>
      <br />
      <u class="wrong"> u 태그의 wrong을 적용한 부분 </u>
    </p>
    <p>
      <i class="not-good"> u태그가 아닌 공통 부분을 not good을 적용한부분 </i>
      <br />
      <b class="wrong"> u태그가 아닌 공통 부분의 not good을 적용한 부분. </b>
    </p>
  </body>
</html>
```

이상의 부분만 확인했을 때에는 i태그와 u 태그의 class가 동일하기 때문에 동일한 css가 적용될거라고 이전까지는 생각했었다.

하지만 00.common.css를 확인 했을 때, 이하에서 볼 수 있듯이 u 태그에서만 --not-good / --wrong을 참조하도록 작성되어 있다 즉, i 태그에서는 wavy underline orange;가 먹히지 않는다는 것이다. 이런 css 상에서의 위계 구조에 대해서도 알 필요가 있다.

```css
/* 특정 요소에서만 사용될 수 있는 변수 목록  */
u {
  --not-good: wavy underline orange;
  --wrong: wavy underline red;
}
.wrong {
  --warn: yellow;
}
/* 
모든 요소에서 사용될 수 있는 변수
*/
:root {
  /* 폰트 사이즈 변수 목록 */
  --font-smail: 8px;
  --font-normal: 16px;
  --font-large: 24px;
  --font-x-large: 32px;
  --font-xx-large: 40px;
  --font-xxx-large: 48px;
  /*  폰트 두께 변수 목록 */
  --font-w-normal: 400;
  --font-w-bold: 600;
  --font-w-extrabold: 900;
  /*  페이지 컬러 목록 */
  --color-main: #ff4200;
  --color-sub: #865a55;
  --color-text: #49281c;
}
```

- :root의 의미
  - 어떤 요소가 특정 태그 내에서만 사용되는 것이 아니라 페이지 전체에서 광범위하게 쓰이게 될 경우 사용하는 표현.
    가상 클래스를 응용하고, root는 예약어로 전체 페이지를 의미한다.

이상의 import문과 그 응용, 그리고 CSS 변수의 개념은 특정 페이지들의 한인 웹 서비스 상에서 공통된 요소와 특정한 요소 부분을 나누어 관리하는 것은 다른 사람과의 협업 체제에서 매우 중요한 부분 중 하나이다.

## 벤더 프리픽스

- trasition 속성
  1. -webkit-trainsition과 같은 방식으로 쓰이는데,
  1. -webkit : 사파리 / 크롬 / 오페라
  1. -moz : 파이어폭스
  1. -ms : 엣지 / 익스플로러
  1. -o : 구 버전 오페라

표준이 정립되는 CSS 속성들의 경우에 각 브라우저가 구현하는대로 동작한다. 그래서 수업 중에 기본앱으로 chrome을 고정했고 즉 , 다른 사용자마다 서로 다른 UX를 가지게 될 수도 있다는 의미이다.

따라서 아직 표준화되지 않았거나 최신 기능이라 사용자의 브라우저가 구버전일 가능성이 있을 때 벤더 프리픽스를 먼저 붙여서 사용하고, 공식 표준 속성은 맨 마지막에 작성한다.

왜냐하면 CSS는 `순서대로` 덮어쓰기 때문에 일단 비표준으로 작성한 것이 후에 표준이 있다면 그걸로 덮어쓰기가 자동으로 이루어지기 때문이다.

# 서체 스타일링

## 서체 및 웹 폰트(필수 / 구글 폰트 및 눈누 폰트 때문에)

### Google Fonts 도입 방법

1. chrome 구글 폰트 검색(Noto KR)
2. 그리고 별 문제가 없다면 Noto Sans Korean을 사용하게 되는데

- Noto : No Tofu를 의미한다.(문자가 깨는 사각형 모양을 두부(Tofu)라고 불렀는데 구글에서 문자가 깨지는 현상을 발생하지 않겠다고 해서 각 국가별 Noto 시리즈가 있다.)
- 모든 언어를 깔금하게 표시할 수 있는 서체.
- 다만 이상을 이유로 너무 보편적이라서 브랜드 사용시에는 적용되지 않는 편이다.

03_wedfont.html

# JavaScript

- 갖다놓는 HTML / 꾸미는 CSS라는 표현을 사용함. 그리고 특정 값의 변화 등을 시키는 역할은 JavaScript가 맡는다.

## 발생 배경

- 지금까지 HTML / CSS를 학습하면서 알 수 있는 점은, 클릭 했을 때 뭐가 변하는 그런 부분이 아니라, 웹 문서를 꾸미는 형태였다.
- JS는 웹페이지를 _동적으로_ 만들기 위해 탄생한 언어이다. 사용자가 버튼을 누르거나 특정 위치에 마우스를 올리거나 하는 등의 행위를 했을 때 상호작용을 할 수 있도록 하여 UX에 엄청난 영향을 끼친 언어라고 할 수 있다.

## 주요 특징

1. 인터프리터 언어 : Java와 달리 Interpreter에 해당하기 때문에 오류나기 전까지는 실행이 된다.
2. 동적 타입(Dynamically Typed) : 변수를 선언할 때 타입을 미리 지정하지 않아도 된다. 코드를 실행 중 스스로 보고 나서 type를 결정한다. Java는 처음에 선언해야 하는 점과는 차이점이 있다.

- 처음에는 좋지만 작성하고나서 테스트 할 때 오류가 발생하는 경우가 많아서 Typescript가 개발되기도 한다

3. 객체 기반(Object-Based): 클래스가 없이도 객체를 만들고 사용하는 것이 가능. 거의 모든 것이 객체로 취급된다(클래스가 없는).
4. 싱글 스레드(Single Thread): 한 번에 하나의 작업만 순차적으로 처리한다. 비동기 처리 개념을 통해서 복잡한 작업을 효율적으로 처리하는 것은 가능하다.

## 장점

1. 웹 브라우저의 기본 언어(language-HTML은 언어가 아니다.) : 별도의 설치 없이 모든 웹 브라우저에서 실행이 된다.(vs code 설치할 때와 intellij 설치할 때 생각하면 intellij일 때는 Java 버전을 다운 받았다)
2. 유연한 문법 : Java를 배운 사람의 경우 자유롭다 싶겠지만 초심자들에게는 장점에 해당한다
3. 다양한 활용분야 : 웹 브라우저 외에도 서버(Node.js),모바일 앱(React Native), 알고리즘까지 폭 넓은 분야에서 사용된다.
4. 생태계 : NPM(Node Package Manager)라는 패키지 저장소를 통해 수많은 오픈소스 라이브러리와 프레임 워크를 활용 가능하다.

- React는 Js의 프레임워크 중 하나이다.

## 단점

1. 보안 : 웹브라우저에서 실행되다 보니 보안관련 설정을 많이 해야한다.(Springboot를 통해서 할 예정)
2. 느린속도 : 이건 사라진 문제
3. 예측 불가능한 오류 : 아까 장점이었던 유연한 문법에 관련된 문제로 실제로 테스트해보기 전까지 어떤 오류가 발생할지 짐작하기 어려운 점이 있었다. - TypeScript로 보완이 가능하지만 덕분에 TypeScript도 배울 예정
4. 브라우저 호환성 문제 :ES6가 나온 이후 사라진 문제

```js
console.log("Hello, JavaScript");
```

이상에서 보면 알 수 있듯이 Js는 "" ' ' 구분 없이 ' '이 기호만 사용한다

앞으로 수업 코드 작성 방식 :
HTML 태그 내에 있는 속성값의 경우에는 ""을 사용하고,
JS 코드와 관련된 부분은 ''을 사용한다

반대로 사용해도 실행이 된다는 점
