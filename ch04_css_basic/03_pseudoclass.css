/* 자손 결합자 */
.outer li {
  color: olivedrab;
}
/* .outer 공백 li로 되어있따는 점을 봤을 때, outer 클래스의 자손 요소인 li 태그들에게 color: olivedrab을 적용하라는 의미가 된다. 그렇기 때문에 ol 요소의 자손 요소인 li들은 여전히 검은색인 상태로 남아있다.

Java 때와 달리 자식 클래스 / 서브 클래스라는 표현을 쓰지 않는 이유는

자식 / 손주 / 증손주 ... 하위 항목들이 전부 다 css의 영향을 받기 때문이다
사과 / 포도 / 딸기 / 키위도 olivedrab이 된 점을 확인 할 수 있다.*/

.outer > li { 
  color: dodgerblue;
}
.outer > li li {
  text-decoration: underline;
}
/*  자손이 아니라 자식만 변경하고 싶다면 '>'가 를 사용하면 된다. 15번 라인의 경우에는 outer 클래스의 li 과일 클래스 안의 ul 클래스가 underline이 적용되는 형태라고 할 수 있다.

.outer > li > li
로 썼을 때도 동일할까?

.outer의 자식인 li의 자식은 ul이라는 점을 감안하면 적용이 불가능 하다.

참고 :
.outer li {color : olivedrab;} 을 없앴다고 가정하면, .outer > l i {color:dodgerblue;}가 '자손'까지 적용된다는 점을 알 수 있다. 이상의 경우는 서제나 텍스트 관련 등 일부 CSS 속성들이 자식들에게 자동상속되기 때문이다. 즉 일촌 자식 결합자(>)라도 여기에 적용된 속성이 자동 상속을 지원하는 속성이라면 이를 덮어쓰는 다른 선택자와 속성을 지정하지 않으면 '자손' 들도 해당 속성들을 물려받는다.
*/

/* '뒤따르는' 모든 동생들 경합자 */
.starter ~ li {
  font-style: italic;
}

/* 뒤따르는 '바로 다음' 동생 결합자 */
.starter + li{ 
  font-weight: bold;
}

/* 가상 클래스 */
/* 
  이상까지는 특정 id나 특정 클래스를 선택해서 스타일을 지정했는데, 가상 클래스는 이와 달리 특정 상황을 가정하고 이름을 붙인다. 작성 방식은 콜론(:)을 사용한다.
*/

ol li:first-child,ol li:last-child {
  color: yellowgreen;
} 

/* ~가 아닌 요소 가상 클래스 */
.outer > li:not(:last-child){
  text-decoration: line-through;
}

ul:not(.outer) li {
  font-weight: bold;
}

/* 
49 번 라인을 해석하면 outer 클래스의 직계 자식인 li 태그 중에 마지막 요소가 아닌 것을 골라 line-through를 적용하라는 의미이다. 그렇다면 직계 자식인 육류, 채소, 유제품, 과일중에서
마지막 과일을 뺀 나머지 세 개에만 취소선이 적용이 된다.

그러면 53번 라인에서 ul 태그중 outer 클래스가 아닌 것을 골라서 bold로 적용하라는 의미. ul 태그는 두 개로 중첩이 되어있기 때문에 들여 쓰기가 적영된 사과,포도,딸기,키위가 포함된 ul은 outer가 적용된 li가 아니므로 bold체가 적용*/

/*  ~번째 요소 가상 클래스 */
/* odd / even / 3n을 () 3 대신 ()에 넣어보면 결과값이 바뀌는 것을 확인 할 수 있다. */
ol li:nth-child(3n){
  font-weight: bold;
  color: pink;
}


li:hover{
  font-weight: bold;
  color: blue;
}
/* hover는 마우스 오버 기능을 지원하는 것 hover의 경우 자주 사용되는 편이다. 그런데 김 3의 경우 pink가 바뀌지 않는 것을 볼 수 있는데 그 이유는 hover: 보다 우선순위가 높기 때문이다. */
